
p in %rdi, q in %rsi
setVal:
    movslq 8(%rsi), %rax        // %rax = *(8 + q)
    addq 32(%rsi), %rax         // %rax += *(32 + q)

    movq %rax, 184(%rdi)        //


这个问题算是非常简单的，由最后一条代码再加上str的结构，我们可以得出这样一个等式
4 * A * B + space = 184 由于对齐原则是保证8的倍数,分别假设space为7和0
==> 44 < A * B <= 46

%rax = *(8 + q) 可以推断出char array[B] 应该总共使用8个字节
因为需要考虑对齐原则，所以先得出 B <= 8

short s[A] %rax += *(32 + q)
我们t占用4个字节  ==> 4 + A * 2 <= 32 - 8 <= 24

于是我们有三个公式来做判断：
44 < A * B <= 46
B <= 8
A <= 10

那么A * B 的值只能是45 组合就是 5 * 9
由于 B <= 8 因此 B = 5 A = 9

我们再验证一番，short s[A] 由于对齐原则 占用了20个字节，跟汇编代码一致

答案：
A = 9
B = 5

